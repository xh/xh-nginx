# Support compression for both static assets and proxy calls
gzip on;
gzip_static on;
gzip_comp_level 2;
gzip_min_length 1000;
gzip_proxied any;
gzip_types application/json application/javascript text/css text/javascript;

# Increase client max body size to allow for larger uploads
client_max_body_size 20m;

# Increase proxy headers hash size due to our use of proxy_set_header - as per nginx msg in log.
proxy_headers_hash_max_size 1024;

# Convenience map to specify caching expiry by request type (use in expires directive as below)
map $sent_http_content_type $expires {
    default                 off;
    application/javascript  max;
    font/woff2              max;
    image/png               max;
    text/css                max;
    text/html               epoch;
}

# Set $is_desktop and $is_mobile variables for simple UA-based sniffing.
# This was snagged from https://gist.github.com/perusio/1326701 and is not guaranteed by any means
# to be perfect or exhaustive. Apps should use with care - we can tune if we have real-world cases
# where we find this is not working as desired.
map $http_user_agent $is_desktop {
    default 0;
    ~*linux.*android|windows\s+(?:ce|phone) 0; # exceptions to the rule
    ~*spider|crawl|slurp|bot 1; # bots
    ~*windows|linux|os\s+x\s*[\d\._]+|solaris|bsd 1; # OSes
}

map $is_desktop $is_mobile {
    1 0;
    0 1;
}

# Set new $xh_jespa_connection_id for use in xh-proxy include, where the resulting value is
# used to add/replace a Jespa-Connection-Id header. If request arrives with a Jespa-Connection-Id
# header already set, this map will re-use that same value: the incoming header is assumed to
# have been set by an upstream proxy or k8s ingress and to contain the actual client addr and port.
# Otherwise, we create the ID with the addr and port we know about here.
map $http_jespa_connection_id $xh_jespa_connection_id {
    volatile;
    default $http_jespa_connection_id;

    ""      $remote_addr:$remote_port;
}


# App-level Dockerfiles must copy in an appropriate conf with server directives such as the below.

#server {
#    server_name  localhost;
#    include includes/xh-secure-redirect.conf;
#}
#server {
#    server_name  localhost;
#    listen 443 ssl;
#    root   /usr/share/nginx/html;
#
#    # Redirect root to /app/
#    location = / {
#        return 301 $scheme://$host/app/;
#    }
#
#    # Static JS/CSS/etc assets not matching a more specific app selector below
#    location / {
#        expires $expires;
#    }
#
#    # App entry points - ensure trailing slash, try for match, fallback to app index for sub-routes
#    location = /admin {
#        return 301 $uri/;
#    }
#    location /admin/ {
#        try_files $uri /admin/index.html;
#        expires $expires;
#    }
#
#    location = /app {
#        return 301 $uri/;
#    }
#    location /app/ {
#        try_files $uri /app/index.html;
#        expires $expires;
#    }
#
#    # Proxy to Grails back-end
#    # Note this *requires* xh-tomcat to be defined by a docker swarm/link (or mocked via etc/hosts)
#    location /api/ {
#        proxy_pass http://xh-tomcat:8080/;
#        include includes/xh-proxy.conf;
#    }
#}
